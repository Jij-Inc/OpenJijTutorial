{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# A3 - 古典イジング模型"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "view-in-github"
   },
   "source": [
    "[![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/OpenJij/OpenJijTutorial/blob/master/source/ja/A003-LargeScaleMC.ipynb)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "この章ではOpenJijのcore interface (core python interface)の使い方を説明し、簡単な計算のデモンストレーションを行います。\n",
    "\n",
    "core interfaceは前回までのチュートリアルよりも下部のレイヤーのAPIです。対象読者としては前回までのOpenJijチュートリアルを一通り終えて、イジングモデルやモンテカルロ法などの用語を知っている方を想定します。次のような目的を持った読者を想定しています。\n",
    "\n",
    "* 最適化問題だけでなくサンプリングや研究用途などより専門的な用途にOpenJijを用いたい\n",
    "* アニーリングスケジュールの設定や使用するアルゴリズム等を直接触りたい"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cxxjij.graph as G\n",
    "#問題サイズを100とします。\n",
    "N = 100\n",
    "\n",
    "graph = G.Dense(N)\n",
    "#sparseの場合は以下を使用します。\n",
    "#graph = G.Sparse(N)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$J_{ij}, h_i$を設定します。今回は平均0、標準偏差1のGauss分布から生成される値を設定します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install numpy #乱数生成にnumpyを使います。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "mu, sigma = 0, 1\n",
    "\n",
    "for i in range(N):\n",
    "    for j in range(N):\n",
    "        #Jijの値が大きくなりすぎてしまうので、1/Nで規格化を行なっています。\n",
    "        graph[i,j] = 0 if i == j else np.random.normal()/N\n",
    "\n",
    "for i in range(N):\n",
    "    graph[i] = np.random.normal()/N"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "縦磁場に関しては、`graph[i]`でも、`graph[i,i]`でもどちらでもアクセスできます。また、イジングモデルの定義上、$J_{ij}$と$J_{ji}$は自動で同じ値となります。試しに以下のように出力を行なってみましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.5\n",
      "0.5\n",
      "-0.6\n",
      "-0.6\n"
     ]
    }
   ],
   "source": [
    "graph[20] = 0.5\n",
    "print(graph[20,20])\n",
    "print(graph[20])\n",
    "graph[12,34] = -0.6\n",
    "print(graph[12,34])\n",
    "print(graph[34,12])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## システムの設定 - System -\n",
    "\n",
    "続いて計算を行うためのシステムを定義します。ここでは古典イジング模型か横磁場イジング模型か、また別の模型にするか等を選べます。  \n",
    "\n",
    "まずは古典イジング模型のシステムを作成してみます。`system.make_classical_ising`で作成できます。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cxxjij.system as S\n",
    "\n",
    "mysystem = S.make_classical_ising(graph.gen_spin(), graph)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ここで、1つ目の引数にはランダムに生成したスピン、2つめにはGraphそのものを代入します。これにより初期のスピン配位が`graph.gen_spin()`となる古典イジング模型のシステムの作成ができます。\n",
    "\n",
    "システムに直接アクセスして、値を読むことも可能です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 1. -1.  1. -1. -1. -1.  1.  1. -1.  1. -1.  1.  1.  1.  1. -1.  1. -1.\n",
      " -1. -1. -1. -1. -1.  1.  1. -1. -1.  1. -1. -1. -1.  1.  1.  1. -1.  1.\n",
      "  1. -1.  1. -1.  1.  1. -1. -1.  1. -1.  1. -1. -1. -1. -1. -1.  1.  1.\n",
      " -1.  1. -1. -1. -1.  1.  1.  1. -1. -1.  1.  1. -1.  1. -1. -1.  1.  1.\n",
      "  1.  1.  1. -1. -1. -1. -1. -1. -1.  1. -1. -1. -1. -1. -1. -1.  1. -1.\n",
      " -1.  1. -1. -1. -1.  1. -1.  1.  1.  1.  1.]\n"
     ]
    }
   ],
   "source": [
    "print(mysystem.spin)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "古典イジング模型以外にも様々なシステムが用意されており、これを用途別に使うことが出来ます。用いるSystemによって初期化の方法は多少異なります。これは後ほど少しずつ紹介していきます。\n",
    "\n",
    "## アルゴリズムの実行 -Updater, Algorithm-\n",
    "\n",
    "Systemを定義した後はUpdaterを選択し、Algorithmを実行していきます。\n",
    "\n",
    "### Updater\n",
    "\n",
    "Systemに対して使用できるUpdaterは決められており、古典イジング模型に対するUpdaterは主に\n",
    "\n",
    "- [SingleSpinFlip](https://github.com/OpenJij/OpenJij/blob/ec41aecfbac7e4c895e1e7a1718f06eb7ffae0ba/src/updater/single_spin_flip.hpp#L40) (メトロポリス・ヘイスティング法によるスピン1つずつのアップデート)\n",
    "- [SwendsenWang](https://github.com/OpenJij/OpenJij/blob/ec41aecfbac7e4c895e1e7a1718f06eb7ffae0ba/src/updater/swendsen_wang.hpp#L45) (SwendsenWang法によるクラスターアップデート)\n",
    "\n",
    "の2つが用意されています。\n",
    "Algorithmを実行するには、**スケジュールリスト**が必要になります。まずスケジュールリストを作成するところから始めましょう。\n",
    "\n",
    "### Algorithm\n",
    "\n",
    "#### スケジュールリスト\n",
    "\n",
    "スケジュールリストは`(パラメータ, モンテカルロステップ数)`のリストで与えられるものです。パラメータ部分に入力する値はSystemによって異なります。例えば、古典イジング模型ならばパラメータとして温度の逆数である逆温度$\\beta$を設定します。例として以下のように設定してみましょう。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "schedule_list = [(0.01, 10),(10, 80),(0.1, 30)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "この場合、逆温度$\\beta=0.01$で10モンテカルロステップ、$\\beta=10$で80ステップ、$\\beta=0.1$で30ステップの計120モンテカルロステップを実行することを意味します。  \n",
    "アニーリングを実行するにあたっては、逆温度は等比級数で増加させていくことが多いため、以下のように`utility`にある`make_classical_schedule_list`を使うとより便利です。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[((beta: 0.100000) mcs: 20), ((beta: 0.199474) mcs: 20), ((beta: 0.397897) mcs: 20), ((beta: 0.793701) mcs: 20), ((beta: 1.583223) mcs: 20), ((beta: 3.158114) mcs: 20), ((beta: 6.299605) mcs: 20), ((beta: 12.566053) mcs: 20), ((beta: 25.065966) mcs: 20), ((beta: 50.000000) mcs: 20)]\n"
     ]
    }
   ],
   "source": [
    "import cxxjij.utility as U\n",
    "schedule_list = U.make_classical_schedule_list(0.1, 50, 20, 10)\n",
    "print(schedule_list)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "上の例では$\\beta=0.1$から$\\beta=50$まで、各温度で20モンテカルロステップ計算しながら10段階で温度を変えていく設定例です。計200モンテカルロステップの計算を行います。\n",
    "\n",
    "#### Algorithmの実行\n",
    "\n",
    "続いて、Algorithmを実行します。`Algorithm_[Updater]_run`のように書くことで、指定したUpdaterで計算を行います。次の例ではSingleSpinFlipを実行しています。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "import cxxjij.algorithm as A\n",
    "A.Algorithm_SingleSpinFlip_run(mysystem, schedule_list)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "一瞬で処理が終わりましたが、この間に計200モンテカルロステップの計算が行われています。\n",
    "> `A.Algorithm_SingleSpinFlip_run(mysystem, seed, schedule_list)`とすることで、seedを固定したまま計算を行うことができます。結果に再現性をもたせたい際に使うことができます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "callbackを使用することで、Algorithmの実行中に1モンテカルロステップごとのシステムを取得することができます。古典イジング模型の場合は、システムとパラメータ (逆温度)を引数を持つ関数を作成すれば良いです。  \n",
    "例として、以下ではシステムのエネルギーの値を記録するcallbackを作っています。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "energies = []\n",
    "\n",
    "def callback_log_energy(system, beta):\n",
    "    #graphは以前にGraphモジュールにて定義したオブジェクトです\n",
    "    energies.append(graph.calc_energy(system.spin))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "このcallbackを用いて同じAlgorithmを実行します。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "#スケジュールをもっと長く取ります (計20000モンテカルロステップ)\n",
    "schedule_list = U.make_classical_schedule_list(0.1, 50, 200, 100)\n",
    "A.Algorithm_SingleSpinFlip_run(mysystem, schedule_list, callback_log_energy)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "記録したシステムのエネルギーを、横軸をモンテカルロステップ、縦軸をエネルギーでプロットすると次のようになります。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "!pip install matplotlib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "plt.plot(range(len(energies)), energies)\n",
    "plt.xlabel('Monte Carlo step')\n",
    "plt.ylabel('energy')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "アニーリングが進むに連れ徐々にエネルギーが低くなっているのが分かります。Algorithmの動作中にシステムの様子を知りたい時に有用です。\n",
    "\n",
    "## 結果の取得 -Result-\n",
    "\n",
    "`result.get_solution`で計算結果であるスピン列を取得できます。古典イジング模型の場合は直接`mysystem.spin`を参照することで、スピン列を取得も可能です。しかし、`result.get_solution`はそれ以外のシステムについてもスピン列を取得できる便利なメソッドです。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, 1, 1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1]\n"
     ]
    }
   ],
   "source": [
    "import cxxjij.result as R\n",
    "print(R.get_solution(mysystem))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "このスピン列がアニーリングによって得られた答えです。ハミルトニアンの基底状態 (に近い状態)であることが期待されます。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## C++ core interface\n",
    "\n",
    "多少の違いはありますが、C++ core interfaceでも上記とほぼ同じことが可能です。以下の点に留意しましょう。\n",
    "\n",
    "- seed値を入れる引数には、乱数生成器 (C++11 random)を代入する必要があります。\n",
    "- Graphクラスで、$J_{ij}, h_i$へのアクセス方法が多少異なります。\n",
    "\n",
    "今までの内容をC++ core interfaceで記述すると次のようになります。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "```cpp\n",
    "#include <graph/all.hpp>\n",
    "#include <system/all.hpp>\n",
    "#include <updater/all.hpp>\n",
    "#include <algorithm/all.hpp>\n",
    "#include <result/all.hpp>\n",
    "#include <utility/schedule_list.hpp>\n",
    "#include <utility/random.hpp>\n",
    "#include <random>\n",
    "\n",
    "#include <iostream>\n",
    "\n",
    "using namespace openjij;\n",
    "\n",
    "int main(void){\n",
    "\n",
    "    //generate dense graph with size N=100\n",
    "    constexpr std::size_t N = 100;\n",
    "    auto dense = graph::Dense<double>(N);\n",
    "\n",
    "    //generate random engine\n",
    "    auto rand_engine = std::mt19937(0x1234);\n",
    "    //of course you can specify another random generator that is compatible with C++ random generator, say utility::Xorshift,\n",
    "    //auto rand_engine = utility::Xorshift(0x1234);\n",
    "    \n",
    "    //Gaussian distribution\n",
    "    auto gauss = std::normal_distribution<>{0, 1};\n",
    "\n",
    "    //set interactions\n",
    "    for(std::size_t i=0; i<N; i++){\n",
    "        for(std::size_t j=0; j<N; j++){\n",
    "            dense.J(i, j) = (i == j) ? 0 : gauss(rand_engine)/N;\n",
    "        }\n",
    "    }\n",
    "\n",
    "    //set local fields\n",
    "    for(std::size_t i=0; i<N; i++){\n",
    "        dense.h(i) = gauss(rand_engine);\n",
    "    }\n",
    "\n",
    "    //create classical Ising system\n",
    "    auto system = system::make_classical_ising(dense.gen_spin(rand_engine), dense);\n",
    "\n",
    "    //generate schedule list\n",
    "    //from beta=0.1 to beta=50, 20 Monte Carlo step for each tempearature, 10 samples\n",
    "    auto schedule_list = utility::make_classical_schedule_list(0.1, 50, 20, 10);\n",
    "\n",
    "    //or in the case of classical system, you can specify arbitrary schedules by using a std::vector of utility::Schedule<system::classical_system>\n",
    "    //std::vector<utility::Schedule<system::classical_system>> schedule_list;\n",
    "    //utility::Schedule<system::classical_system> schedule;\n",
    "    //schedule.updater_parameter = {0.01};\n",
    "    //schedule.one_mc_step = 10; //number of Monte Carlo step per temperature\n",
    "    //schedule_list.push_back(schedule);\n",
    "    //\n",
    "    //schedule.updater_parameter = {10};\n",
    "    //schedule.one_mc_step = 80; //number of Monte Carlo step per temperature\n",
    "    //schedule_list.push_back(schedule);\n",
    "    //\n",
    "    //schedule.updater_parameter = {0.1};\n",
    "    //schedule.one_mc_step = 30; //number of Monte Carlo step per temperature\n",
    "    //schedule_list.push_back(schedule); //schedule_list -> [(0.01, 10), (10, 80), (0.1, 30)]\n",
    "\n",
    "\n",
    "    //do annealing (updater: SingleSpinFlip)\n",
    "    algorithm::Algorithm<updater::SingleSpinFlip>::run(system, rand_engine, schedule_list);\n",
    "\n",
    "    //show spins\n",
    "    std::cout << \"The result spins are [\";\n",
    "    for(auto&& elem : result::get_solution(system)){\n",
    "        std::cout << elem << \" \";\n",
    "    }\n",
    "\n",
    "    std::cout << \"]\" << std::endl;\n",
    "}\n",
    "\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
